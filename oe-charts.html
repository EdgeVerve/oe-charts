<script type="text/javascript" src="../d3/d3.min.js"></script>
<script type="text/javascript" src="../lodash/lodash.js"></script>
<script type="text/javascript" src="countries/topojson.js"></script>
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../oe-ajax/oe-ajax.html">
<link rel="import" href="oe-chart-behavior.html">

<link rel="stylesheet" type="text/css" href="xCharts.css">
<!--
  ### oe-charts

  `<oe-charts>` is a charting library which provides polymer based charting components.
  
  ### Chart properties
  property | type | required | default | description
  ---------|------|----------|---------|---------------------
  `chartType` | string | no | `groupedColumn` | Following are the supported chartTypes  - area, bubble, groupedbar, groupedcolumn, line, normalizedstackedcolumn, pareto, pie, donut, stackedbar, stackedcolumn, mapview.
  `dataUrl` | string | no (if data property is provided) |  | `dataUrl` should be passed incase the data for the chart is linked with any end point url. Like `/api/ChartData` This url is supposed to provide data in a format of array.
  `category` | string | yes |  | `category` property is used to define the x-axis in chart. It accepts a property name from the individual element of from data.
  `series` | array | yes |  | `series` accepts an array where each element is an object. Properties of each element can be  any among `property`, `aggregation`, `color`. A sample series element can be as - `{"property":"age","aggregation":"sum","color":"#f5f5f5"}`. Aggregation value can be `sum`, `count`  or `average`. Charts can be of multiple series. So multiple values can be provided via array.
  `data` | array | no( if `dataUrl` property is set ) |  | `data` property is required to render the data. It should be an array of objects. If `dataUrl` property is set then data is not required.
  `chartWidth` | number | no | 300px | `chartWidth` can be provided to set the width of the container of the chart.
  `chartHeight` | number | no | 300px | `chartHeight` can be provided to set the height of the container of the chart.
  `inheritParentDimension` | string | no | false | It can be set to true in case of chart container is suppsed to get the dimension on its parent container. If this property is given and if the parent is resized, in that case the chart will get redrawn occupying the new dimension.
  `categoryAggregator` | string | no |   | Please provide a description
  `categorylabelFormat` | string | no |   | Please provide a description

  @demo demo/demo-oe-data-table.html
-->
<dom-module id="oe-charts">
  <template>
    <style>
       :host {
        display: block;
        position: relative;
      }
    </style>
    <div id="[[renderContainerId]]" style$="height:[[chartHeight]]px;width:[[chartWidth]]px">

    </div>
  </template>
  <script>
    Polymer({
      is: "oe-charts",
      properties: {
        chartType: {
          type: String,
          value: function () {
            // default chart type is grouped column
            return "groupedColumn"
          }
        },
        renderContainerId: {
          type: String,
          value: function () {
            return 'chart-' + this.getGUID();
          }
        },
        data: {
          type: Array,
          value: function () {
            return [];
          }
        },
        //when category changes, a function from utility will get invoked.
        category: {
          type: String,
          value: function () {
            return "";
          }
        },
        categoryAggregator: {
          type: String,
          value: function () {
            return null;
          }
        },
        categorylabelFormat: {
          type: String,
          value: function () {
            return "";
          }
        },
        series: {
          type: Array,
          value: function () {
            return [];
          }
        },
        //when data url changes, a function from utility will get invoked.
        dataUrl: {
          type: String,
          value: function () {
            return "";
          },
          observer: 'dataUrlChanged'
        },
        changeStreamUrl: {
          type: String,
          value: function () {
            return "";
          },
          observer: 'registerChangeStream'
        },
        chartWidth: {
          type: Number,
          value: 300
        },
        chartHeight: {
          type: Number,
          value: 300
        },
        inheritParentDimension: {
          type: Boolean,
          value: false,
          observer: '_handleInheritance'
        },
        drawNew: {
          type: Boolean,
          value: function () {
            return true;
          }
        }
      },
      behaviors: [OEchartBehavior],
      observers: ['parameterChanged(series.*,category,chartHeight,categoryAggregator,chartWidth,chartType)', 'dataChanged(data.*)'],
      attached: function () {
        this.aggregateFunctions = {
          'sum': function (data) {
            return data.reduce(function (a, b) {
              return a + b;
            });
          },
          'average': function (data) {
            var sum = data.reduce(function (a, b) {
              return a + b;
            });
            return sum / data.length;
          },
          'count': function (data) {
            return data.length;
          }
        }
        this.chartTypes = {
          'area': 'area',
          'bubble': 'bubble',
          'groupedbar': 'groupedBar',
          'groupedcolumn': 'groupedColumn',
          'line': 'line',
          'normalizedstackedcolumn': 'normalizedStackedColumn',
          'pareto': 'pareto',
          'pie': 'pie',
          'donut': 'donut',
          'stackedbar': 'stackedBar',
          'stackedcolumn': 'stackedColumn',
          'mapview': 'mapview',
        }
        this.init();
      },
      registerChangeStream: function () {
        if (!this.changeStreamUrl)
          return;
        var src = new EventSource(this.changeStreamUrl);
        src.addEventListener('data', function (msg) {
          var data = JSON.parse(msg.data);
          data = data.data;
          if (data)
            this.push('data', data);
        }.bind(this));
      },
      _handleInheritance: function () {
        var parentElem = this.parentElement;
        if (this.inheritParentDimension) {
          this._dimensionInteraval = setInterval(function () {
            this.debounce('update-chart-dimensions', function () {
              if (this.chartHeight !== parentElem.offsetHeight || this.chartWidth !== parentElem.offsetWidth) {
                this.set('drawNew', true);
                this.set('chartHeight', parentElem.offsetHeight);
                this.set('drawNew', true);
                this.set('chartWidth', parentElem.offsetWidth);
              }
            }, 499);
          }.bind(this), 500);
        } else {
          clearInterval(this._dimensionInteraval)
        }
      },
      checkAndRender: function (data) {
        if (Array.isArray(data) && data.length === 0)
          return;
        if (!this.chartTypes || !this.aggregateFunctions) {
          return;
        }
        if (this.ifStructuredData(data))
          this.render(data);
        else {
          this.render(this.restructureData(data, this.category, this.series));
        }

      },
      render: function (data) {
        if (!this.ifStructuredData(data))
          return;
        if (this.drawNew) {
          this.chart = new this.xChart.chart(this.renderContainerId);
          this.chartId = this.getGUID();
          this.drawNew = false;
        }
        Polymer.dom.flush();
        var container = this.querySelector('#' + this.renderContainerId);
        if (container.offsetHeight < 200 || container.offsetWidth < 200) {
          return;
        }
        this.chart.setOptions({
          chartClientId: this.renderContainerId,
          chartType: this.chartTypes[this.chartType.toLowerCase()],
          overlap: false
        });
        this.chart.render(data);
      },
      dataUrlChanged: function () {
        if (!this.dataUrl)
          return;
        this.makeAjaxCall(this.dataUrl, 'get', null, null, null, function (err, resp) {
          if (resp) {
            this.set('data', resp);
          }
        }.bind(this));
      },
      dataChanged: function () {
        this.checkAndRender(this.data);
      },
      parameterChanged: function () {
        this.set('drawNew', true);
        this.checkAndRender(this.data);
      },
      restructureData: function (data, category, series) {
        if (!data || !category || !series || series.length === 0)
          return;
        var categorylabelFormat = this.categorylabelFormat;
        var groups = this.getGroups(data, category, this.categoryAggregator);
        var categoryData = Object.keys(groups).map(function (d) {
          return {
            "longName": d,
            "name": categorylabelFormat + d,
            "value": d,
            'dimName': d
          };
        });
        var seriesData = series.map(function (d) {
          d.aggregation = d.aggregation || 'sum';
          var aggFunc = this.aggregateFunctions[d.aggregation];
          var newgroup = Object.assign({}, groups);
          //newgroup=groups;
          if (d.filter && d.filter !== null) {
            _.forEach(newgroup, function (value, key) {
              newgroup[key] = _.filter(newgroup[key], function (data) {
                return data[d.property] === d.filter
              });
            });
          }
          var data = this.getSeriesData(newgroup, d.property, aggFunc);
          var fmtData = data.map(function (d) {
            return d.toString();
          });
          return {
            "longName": d.longName || d.property,
            "name": d.name || d.property,
            "value": d.name || d.property,
            "data": data,
            "fmtData": fmtData,
            "minValue": {},
            "maxValue": {},
            "axis": null,
            "color": d.color
          };
        }.bind(this));
        var formattedData = {
          categories: categoryData,
          series: seriesData
        };
        return formattedData;
      },
      getGroups: function (data, category, categoryAggregator) {
        if (categoryAggregator) {
          var categoryFunction;
          switch (categoryAggregator.toLowerCase()) {
            case 'year':
              categoryFunction = function (rec) {
                return (new Date(rec[category])).getFullYear();
              }
              break;
            case 'quarter':
              categoryFunction = function (rec) {
                return Math.ceil(((new Date(rec[category])).getMonth() + 1) / 3);
              }
              break;
            case 'month':
              categoryFunction = function (rec) {
                return (new Date(rec[category])).getMonth();
              }
              break;
            default:
              categoryFunction = function (rec) {
                return OEUtils.dateUtils.format(new Date(rec[category]), categoryAggregator);
              }
              break;
          }
          return _.groupBy(data, categoryFunction);
        } else {
          return _.groupBy(data, category);
        }
      },
      getSeriesData: function (data, series, aggregation) {
        return _.map(data, function (d) {
          return d.map(function (e) {
            return parseFloat(e[series]);
          });
        }).map(function (k) {
          return aggregation(k);
        });
      },
      ifStructuredData: function (data) {
        if (typeof data === 'object') {
          if (data.categories && data.series && Array.isArray(data.categories) && Array.isArray(data.series))
            return true;
        }
        return false;
      },
      getGUID: function () {
        var randoms = (window.crypto || window.msCrypto).getRandomValues(new Uint32Array(2)); // eslint-disable-line no-undef
        return randoms[0].toString(36).substring(2, 15) +
          randoms[1].toString(36).substring(2, 15);
      },
      init: function () {
        //setting random id to the chart container
        // var container = this.querySelector('#chartContainer');
        // var chartName = 'chart-' + this.getGUID();
        // container.setAttribute('id', chartName);
        // this.set('renderContainerId', chartName);
        this.parameterChanged();
      },
      makeAjaxCall: function (url, method, body, filters, header, cb) {
        var ajax = document.createElement('oe-ajax');
        ajax.url = url;
        ajax.method = method;
        if (body) {
          ajax.body = JSON.stringify(body);
        }
        ajax.contentType = "application/json";
        ajax.addEventListener('response', function (resp, err) {
          this.fire('end-spinner');
          cb(null, resp.detail.response);
        }.bind(this));
        ajax.addEventListener('error', function (err) {
          this.fire('end-spinner');
          cb(err, null);
        }.bind(this));
        this.fire('start-spinner', {
          url: ajax.url
        });
        ajax.generateRequest();
      }
    });
  </script>
</dom-module>